import os
import sys
import time
import ctypes
import shutil
import subprocess
import threading
import multiprocessing
import concurrent.futures
import glob
import winreg
import psutil
import wmi
import pythoncom
import re
import win32api
import win32con
from datetime import datetime
from typing import List, Dict, Tuple, Optional, Any

# ==================== AUTO ADMIN ELEVATION ====================
# Ini harus dijalankan di awal sebelum kode lain dieksekusi

def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

def run_as_admin():
    if not is_admin():
        print("[SYSTEM] Requesting Administrator Privileges...")
        ctypes.windll.shell32.ShellExecuteW(
            None, "runas", sys.executable, " ".join(sys.argv), None, 1
        )
        sys.exit()

# Auto Elevate
run_as_admin()

# ==================== KONFIGURASI GLOBAL & PATHS ====================

# 1. Daftar Path Cleaner (Gabungan Lengkap dari referensi)
CLEAN_PATHS = {
    "System Temp": [
        "%WINDIR%\\Temp\\*",
        "%WINDIR%\\Prefetch\\*",
        "%WINDIR%\\Logs\\*.log",
        "%WINDIR%\\SoftwareDistribution\\Download\\*",
    ],
    "User Temp": [
        "%TEMP%\\*", "%TMP%\\*", "%LOCALAPPDATA%\\Temp\\*",
    ],
    "Thumbnail & Icon Cache": [
        "%LOCALAPPDATA%\\Microsoft\\Windows\\Explorer\\thumbcache_*.db",
        "%LOCALAPPDATA%\\Microsoft\\Windows\\Explorer\\iconcache_*.db",
    ],
    "Browser Cache (Chrome/Edge/Firefox)": [
        "%LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\Cache\\*",
        "%LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\Code Cache\\*",
        "%LOCALAPPDATA%\\Microsoft\\Edge\\User Data\\Default\\Cache\\*",
        "%APPDATA%\\Mozilla\\Firefox\\Profiles\\*\\cache2\\*",
    ],
    "App Cache (Discord/Steam/Adobe/Nvidia)": [
        "%APPDATA%\\discord\\Cache\\*",
        "C:\\Program Files (x86)\\Steam\\appcache\\*",
        "%APPDATA%\\Adobe\\Common\\Media Cache\\*",
        "%LOCALAPPDATA%\\NVIDIA\\GLCache\\*",
    ],
    "Driver Leftovers (AMD/Nvidia/Intel)": [
        "C:\\NVIDIA\\*", "C:\\AMD\\*", "C:\\Intel\\*",
    ],
    "Windows Error & Memory Dumps": [
        "C:\\Windows\\Minidump\\*.dmp", "C:\\Windows\\memory.dmp",
        "%LOCALAPPDATA%\\CrashDumps\\*",
    ],
    "Telemetry & Traces": [
        "C:\\Windows\\System32\\SleepStudy\\*",
        "C:\\ProgramData\\Microsoft\\Diagnosis\\ETLLogs\\AutoLogger\\*.etl",
    ]
}

# 2. Daftar Registry Privasi
PRIVACY_REGISTRY_KEYS = [
    "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs",
    "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU",
    "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\TypedPaths",
    "HKCU\\Software\\Microsoft\\Internet Explorer\\TypedURLs",
    "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Paint\\Recent File List",
]

# 3. Daftar Bloatware
BLOATWARE_APPS = [
    "Microsoft.549981C3F5F10", # Cortana
    "Microsoft.BingWeather", "Microsoft.BingNews",
    "Microsoft.GetHelp", "Microsoft.Getstarted",
    "Microsoft.MicrosoftOfficeHub", "Microsoft.Office.OneNote",
    "Microsoft.SkypeApp", "Microsoft.Wallet",
    "Microsoft.Xbox.TCUI", "Microsoft.XboxGameOverlay",
    "Microsoft.YourPhone", "Microsoft.ZuneMusic", "Microsoft.ZuneVideo",
]

# ==================== RESOURCE MANAGER (TURBO MODE) ====================

class TurboResourceManager:
    """
    Mengelola resource virtual: 
    - Alokasi memori besar (Simulasi GPU Buffer).
    - Pembuatan Virtual Memory sementara di Drive D: (10GB).
    """
    def __init__(self):
        self.swap_file_path = "D:\\neoopt_turbo_swap.bin"
        self.buffer_block = None
        self.buffer_size = 2 * 1024 * 1024 * 1024 # 2GB Buffer
        
    def allocate_resources(self):
        print(f"[TURBO] Allocating Resources...")
        
        # 1. Alokasi RAM Buffer (Simulasi VRAM GPU)
        try:
            self.buffer_block = bytearray(self.buffer_size)
            print(f"[TURBO] GPU/RAM Buffer Allocated: {self.buffer_size // (1024*1024*1024)} GB")
        except MemoryError:
            print("[WARNING] RAM tidak cukup untuk buffer penuh, menggunakan buffer dinamis.")
            self.buffer_block = None

        # 2. Buat Virtual Memory di Drive D: (Jika ada)
        if os.path.exists('D:\\'):
            try:
                if not os.path.exists(self.swap_file_path):
                    print(f"[TURBO] Creating 10GB Virtual Swap on Drive D: {self.swap_file_path}")
                    with open(self.swap_file_path, 'wb') as f:
                        # Seek ke 10GB dan tulis 1 byte (Sparse file logic for speed)
                        f.seek(10 * 1024 * 1024 * 1024 - 1)
                        f.write(b'\0')
            except Exception as e:
                print(f"[ERROR] Failed to create swap: {e}")
        else:
            print("[INFO] Drive D: not found. Virtual Swap skipped.")

    def release_resources(self):
        print("[TURBO] Releasing Resources...")
        
        if self.buffer_block:
            del self.buffer_block
            self.buffer_block = None
            print("[TURBO] GPU/RAM Buffer Freed.")

        if os.path.exists(self.swap_file_path):
            try:
                os.remove(self.swap_file_path)
                print("[TURBO] Virtual Swap Deleted.")
            except Exception:
                pass

# ==================== NEOOPTIMIZE MAIN ENGINE ====================

class NeoOptimizeEngine:
    VERSION = "Ultimate v4.0"
    
    def __init__(self):
        self._stop_flag = threading.Event()
        self.lock = threading.Lock()
        
        # Resource Manager
        self.resource_manager = TurboResourceManager()
        
        # WMI for Drivers
        try:
            pythoncom.CoInitialize()
            self.wmi_conn = wmi.WMI()
        except:
            self.wmi_conn = None

    # --- UTILITY ---

    def _log(self, msg):
        print(f"[{datetime.now().strftime('%H:%M:%S')}] {msg}")

    def _resolve_path(self, path):
        return os.path.expandvars(path)

    def _format_size(self, n):
        for u in ['B', 'KB', 'MB', 'GB']:
            if n < 1024.0: return f"{n:.2f} {u}"
            n /= 1024.0
        return f"{n:.2f} TB"

    def _run_cmd(self, cmd, shell=True):
        try:
            si = subprocess.STARTUPINFO()
            si.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            si.wShowWindow = subprocess.SW_HIDE
            p = subprocess.Popen(cmd, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE, startupinfo=si)
            out, err = p.communicate()
            return p.returncode == 0, out.decode('utf-8', errors='ignore')
        except Exception:
            return False, ""

    # --- TURBO SCANNER (PARALLEL & FAST) ---

    def scan_junk_turbo(self) -> Tuple[List[Dict], int]:
        """
        Turbo Scan menggunakan ThreadPoolExecutor dan os.scandir.
        Menggunakan buffer resource manager untuk menahan tekanan memori.
        """
        self._stop_flag.clear()
        self.resource_manager.allocate_resources()
        
        self._log("Starting TURBO SCAN...")
        start_time = time.time()
        
        results = []
        total_size = 0
        
        # Fungsi worker untuk thread pool
        def scan_worker(pattern):
            local_files = []
            resolved = self._resolve_path(pattern)
            try:
                # Gunakan glob untuk wildcard awal
                paths = glob.glob(resolved, recursive=True)
                for p in paths:
                    if self._stop_flag.is_set(): break
                    try:
                        if os.path.isdir(p):
                            # Rekursif manual dengan scandir (Super cepat)
                            size = self._scan_dir_recursive(p, local_files)
                            with self.lock: total_size += size
                        elif os.path.isfile(p):
                            size = os.path.getsize(p)
                            local_files.append({'path': p, 'size': size, 'type': 'file'})
                            with self.lock: total_size += size
                    except Exception: pass
            except Exception: pass
            return local_files

        # Jalankan Parallel Scan
        with concurrent.futures.ThreadPoolExecutor(max_workers=multiprocessing.cpu_count() * 2) as executor:
            futures = []
            for cat, patterns in CLEAN_PATHS.items():
                for pat in patterns:
                    futures.append(executor.submit(scan_worker, pat))
            
            for future in concurrent.futures.as_completed(futures):
                try:
                    files = future.result()
                    results.extend(files)
                except: pass

        duration = time.time() - start_time
        self._log(f"Scan Complete: {len(results)} files found in {duration:.2f}s")
        
        # Release resources setelah scan selesai
        self.resource_manager.release_resources()
        
        return results, total_size

    def _scan_dir_recursive(self, path, result_list):
        """Helper recursif cepat"""
        total = 0
        try:
            with os.scandir(path) as it:
                for entry in it:
                    if self._stop_flag.is_set(): break
                    try:
                        if entry.is_dir(follow_symlinks=False):
                            total += self._scan_dir_recursive(entry.path, result_list)
                        elif entry.is_file(follow_symlinks=False):
                            size = entry.stat().st_size
                            result_list.append({'path': entry.path, 'size': size, 'type': 'file'})
                            total += size
                    except (PermissionError, OSError): pass
        except (PermissionError, OSError): pass
        return total

    # --- CLEANER ACTIONS ---

    def clean_junk(self, file_list):
        self._log(f"Cleaning {len(file_list)} items...")
        deleted = 0
        space = 0
        for item in file_list:
            try:
                if os.path.isfile(item['path']):
                    os.unlink(item['path'])
                    deleted += 1; space += item['size']
                elif os.path.isdir(item['path']):
                    shutil.rmtree(item['path'], ignore_errors=True)
                    deleted += 1
            except: pass
        self._log(f"Cleaned {deleted} items. Freed: {self._format_size(space)}")
        return space

    # --- DRIVER CLEANER ---

    def scan_drivers(self):
        self._log("Scanning Third-Party Drivers...")
        drivers = []
        success, output = self._run_cmd("dism /online /get-drivers /format:table")
        if success:
            for line in output.split('\n'):
                if "oem" in line and ".inf" in line:
                    parts = line.split()
                    if len(parts) >= 5 and "Microsoft" not in parts[2]:
                        drivers.append({
                            'name': parts[0], 'provider': parts[2], 'date': parts[3], 'class': parts[1]
                        })
        return drivers

    def remove_driver(self, oem_name):
        self._log(f"Removing driver: {oem_name}")
        return self._run_cmd(f"pnputil /delete-driver {oem_name} /uninstall /force")

    # --- PRIVACY & REGISTRY ---

    def clean_privacy(self):
        self._log("Cleaning Privacy Traces...")
        count = 0
        hives = {"HKCU": winreg.HKEY_CURRENT_USER, "HKLM": winreg.HKEY_LOCAL_MACHINE}
        
        for reg_path in PRIVACY_REGISTRY_KEYS:
            try:
                parts = reg_path.split("\\", 1)
                hive = hives.get(parts[0])
                sub_path = parts[1]
                if hive:
                    key = winreg.OpenKey(hive, sub_path, 0, winreg.KEY_ALL_ACCESS)
                    # Clear values
                    while True:
                        try:
                            val = winreg.EnumValue(key, 0)
                            winreg.DeleteValue(key, val[0])
                            count += 1
                        except OSError: break
                    winreg.CloseKey(key)
            except: pass
        self._log(f"Cleaned {count} registry traces.")

    # --- BLOATWARE ---

    def remove_bloatware(self):
        self._log("Removing Bloatware...")
        removed = 0
        for app in BLOATWARE_APPS:
            cmd = f"powershell -Command \"Get-AppxPackage '{app}' | Remove-AppxPackage -AllUsers\""
            s, _ = self._run_cmd(cmd)
            if s: removed += 1
        self._log(f"Removed {removed} bloatware apps.")

    # --- SYSTEM OPTIMIZER ---

    def optimize_network(self):
        self._log("Optimizing Network...")
        self._run_cmd("ipconfig /flushdns")
        self._run_cmd("netsh winsock reset")
        self._run_cmd("netsh int ip reset")
        self._run_cmd("netsh interface ip delete arpcache")
        self._log("Network Reset Complete.")

    def optimize_boot(self):
        self._log("Optimizing Boot...")
        self._run_cmd("bcdedit /timeout 10")
        cores = multiprocessing.cpu_count()
        self._run_cmd(f"bcdedit /set numproc {cores}")
        self._log("Boot Config Optimized.")

    def stop(self):
        self._stop_flag.set()

# ==================== MAIN MENU (CLI) ====================

def main():
    print("\n" + "="*60)
    print(f" NEOOPTIMIZE ENGINE - {NeoOptimizeEngine.VERSION}")
    print(" Administrator Mode: ACTIVE")
    print("="*60)

    engine = NeoOptimizeEngine()
    
    while True:
        print("\n[MAIN MENU]")
        print("1. TURBO SCAN (Scan Cepat Junk File - Resource Intensive)")
        print("2. FULL CLEAN (Scan & Clean Junk + Privacy + Network)")
        print("3. DRIVER CLEANER (Scan & Remove Old Drivers)")
        print("4. REMOVE BLOATWARE (Uninstall Pre-installed Apps)")
        print("5. SYSTEM OPTIMIZE (Boot & Network Settings)")
        print("0. EXIT")
        
        choice = input("\nSelect > ")

        if choice == '1':
            files, size = engine.scan_junk_turbo()
            print(f"\nResult: {len(files)} files, {engine._format_size(size)}")
            if input("Delete files? (y/n): ").lower() == 'y':
                engine.clean_junk(files)

        elif choice == '2':
            # 1. Scan & Clean Junk
            files, size = engine.scan_junk_turbo()
            engine.clean_junk(files)
            # 2. Privacy
            engine.clean_privacy()
            # 3. Network
            engine.optimize_network()
            print("\n>>> FULL CLEAN COMPLETE <<<")

        elif choice == '3':
            drivers = engine.scan_drivers()
            if not drivers:
                print("No third-party drivers found.")
            else:
                print("\n[Third-Party Drivers Found]")
                for i, d in enumerate(drivers):
                    print(f"{i+1}. {d['name']} | Provider: {d['provider']} | Class: {d['class']}")
                
                try:
                    idx = int(input("\nEnter number to DELETE (0 to cancel): ")) - 1
                    if 0 <= idx < len(drivers):
                        success, msg = engine.remove_driver(drivers[idx]['name'])
                        print("Result:", "Success" if success else f"Failed: {msg}")
                except: pass

        elif choice == '4':
            engine.remove_bloatware()
        
        elif choice == '5':
            engine.optimize_boot()
            engine.optimize_network()
            print("System optimized. Restart recommended.")

        elif choice == '0':
            print("Exiting...")
            break

if __name__ == "__main__":
    main()